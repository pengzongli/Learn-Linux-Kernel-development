操作系统和内核简介

1.操作系统：整个系统中负责完成最基础功能和系统管理的那些部分，这些部分应该包括内核、设备驱动程序、启动引导程序、命令行Shell或者其他种类的用户界面、基础文件管理工具和系统工具。

2.内核：通常一个内核由负责响应中断的中断服务程序，负责管理多个进程从而分享处理器时间的调度程序，负责管理进程地址空间的内存管理程序和网络、进程间通信的系统服务程序共同组成。

3.内核空间和用户空间：
操作系统的核心是内核，它独立于普通的应用程序，可以访问受保护的内存空间，也有访问底层硬件设备的所有权限。为了保证内核的安全，现在的操作系统一般都强制用户进程不能直接操作内核。具体的实现方式基本都是由操作系统将虚拟地址空间划分为两部分，一部分为内核空间，另一部分为用户空间。

应用程序在用户空间执行，它们只能看到允许他们使用的部分系统资源，并且只使用某些特定系统功能，不能直接访问硬件，也不能访问内核划给别人的内存范围，还有一些其他的使用限制。

总的来说，就是内核空间可以执行任意命令，调用系统的一切资源，而用户空间只能执行简单的运算，不能直接调用系统资源，必须通过系统调用（system call），才能向内核发出指令。

ps：top命令输出的第三行就是有CPU在user space和kernel space的时间分配统计。
    time命令可以看某个程序耗时。

4.用户空间进入内核空间
前面说到了用户空间进入内核空间必须通过系统调用，网上看到的资料说，总共有三种方式：系统调用、软中断和硬件中断，这里三种方式后面在做详细总结。

当一个应用程序执行一条系统调用的时候，我们说内核正在代其执行。进一步解释，在这种情况下，应用程序被称为通过系统调用在内核空间运行，而内核被称为运行于进程的上下文中。对于一个进程来说，从用户空间进入到内核空间并最终返回用户空间，这个过程是十分复杂的。举个例子，我们经常接触的概念“堆栈”，其实进程在内核态和用户态各有一个堆栈。运行在用户空间时进程使用的是用户空间中的堆栈，而运行在内核空间时，进程使用的是内核空间中的堆栈。所以说Linux中每个进程有两个栈，分别用于内核态和用户态。

内核管理系统的硬件设备的时候，提供了中断机制。当硬件设备想要和系统通信的时候，它首先发出一个异步中断的信号去打断处理器的执行，继而打断内核的执行。中断通常对应着一个终端号，内核通过这个中断号找到相应的中断服务程序，并调用这个程序响应和处理中断。为了确保中断服务程序能够第一时间响应和处理中断请求，中断服务程序并不在进程的上下中执行，而是在一个与所有进程无关的、专门的中断上下文中执行。

实际上我们可以将每个处理器在任何时间点上的活动概括为以下三种情况：
(1)运行于用户空间，执行用户进程。
(2)运行于内核空间，处于进程上下文，代表某个特定的进程执行。
(3)运行于内核空间，处于中断上下文，与任何进程无关，处理某个特定的中断。
即使CPU空闲，内核也会运行一个空进程，处于进程的上下文，但运行于内核空间。

5.单内核和微内核
单内核：以单个静态二进制文件的形式存放在磁盘中。所有的内核服务都在一个大内核地址空间上运行。内核之间的通信是微不足道的。因为都是运行在内核态，并且同处于一地址空间：内核可以直接调用函数，这和用户空间应用程序没有什么区别。单模块具有简单和性能高的特点。

微内核：微内核被划分为多个独立的过程，每个过程叫做一个服务器。只有强烈请求特权的服务的服务器才会运行在特权模式下，其他服务器都运行在用户空间。所有的服务器都保持独立并运行在各自的地址空间上。因此，不能像单模块内核那样直接调用函数，而是通过消息传递微内核通信：系统采用了进程间通信（IPC）机制。各个服务器之间通过IPC机制互通消息，互换“服务“。服务器的各自独立可以避免一个服务器失效而祸及另一个。模块化的系统允许一个服务器为了另一个服务器而换出。
IPC机制的开销多于函数调用，又涉及内核空间与用户空间的上下文切换，所以消息的传递需要周期，单内核中简单的函数调用没有这些开销。所以，在实际应用中基于微内核的系统都让大部分或全部服务器位于内核，这样就可以直接调用函数，消耗频繁的上下文切换。但是这违背了微内核的设置初衷。

Linux是一个单内核，Linux内核是运行在单独的内核地址空间上的。但是linux汲取了微内核的精华：模块化设计、抢占式内核、支持内核线程、动态装载内核模块的能力。同时linux也避免了微内核设计上的缺陷，让所有的事情都运行在内核态，直接调用函数，无需消息传递。

6.Linux内核和传统Unix系统之间的差异：
Linux支持动态加载内核模块。
Linux支持对称多处理（SMP）机制。
Linux内核可以抢占。
Linux内核并不区分线程和其他的一般进程，对于内核来说，所有的进程都是一样的。
